================================================================================
 üêî CHINA'S RSB GLOBAL OPTIONS EGG #2 ü•ö
================================================================================

Date: 2025-09-15
Time: Current session
Requestor: User
Purpose: RSB global context system to replace custom Config structs

================================================================================
 üéØ EXECUTIVE SUMMARY
================================================================================

RSB uses a global context system that replaces custom Config structs with
centralized get_var(), set_var(), and is_true() functions. All CLI options
are stored as opt_<name> variables accessible throughout the application
without passing config objects around.

================================================================================
 üîç KEY DISCOVERY: GLOBAL CONTEXT REPLACES CONFIG STRUCTS
================================================================================

TRADITIONAL APPROACH:
- Create custom Config structs
- Parse args into struct fields
- Pass config around as parameters

RSB APPROACH:
- Parse args into global opt_* variables
- Access anywhere via global::get_var()
- No config passing needed

================================================================================
 üìä OPTIONS PROCESSING SYSTEM
================================================================================

üéõÔ∏è options() Function Core Logic:
```rust
pub fn options(args: &Args) {
    for arg in args.all() {
        if arg.starts_with("--") {
            // Process long options
        } else if arg.starts_with("-") && arg.len() == 2 {
            // Process short options
        }
    }
}
```

üîß Long Option Processing:
- --verbose ‚Üí opt_verbose="1"
- --config=file.conf ‚Üí opt_config="file.conf"
- --not-verbose ‚Üí opt_verbose="0" (negation)
- --multi=a,b,!c ‚Üí sets multiple opt_* flags

üîß Short Option Processing:
- -v ‚Üí opt_v="1"
- Standard mappings when stdopts feature enabled:
  * -d ‚Üí opt_debug="1"
  * -q ‚Üí opt_quiet="1"
  * -t ‚Üí opt_trace="1"
  * -D ‚Üí opt_dev_mode="1"
  * -y ‚Üí opt_yes="1"
  * -s ‚Üí opt_safe="1"

================================================================================
 üåê GLOBAL CONTEXT ACCESS PATTERNS
================================================================================

üîß Core Access Functions:
```rust
// Setting values
global::set_var("opt_verbose", "1");

// Getting values
let config_file = global::get_var("opt_config");

// Boolean checks
let is_verbose = global::is_true("opt_verbose");
```

üéØ Helper Functions Available:
```rust
// Check if option was provided
has_option("verbose") -> bool

// Get option value if provided
get_option_value("config") -> Option<String>
```

================================================================================
 üîÑ VARIABLE NAMING CONVENTIONS
================================================================================

üè∑Ô∏è Option Variables:
- All options stored with "opt_" prefix
- Dashes converted to underscores
- --my-flag ‚Üí opt_my_flag
- --config-file ‚Üí opt_config_file

üè∑Ô∏è Negation Handling:
- --not-verbose ‚Üí opt_verbose="0"
- Regular flags ‚Üí opt_name="1"
- Value options ‚Üí opt_name="actual_value"

================================================================================
 üõ°Ô∏è PATH VALIDATION SYSTEM
================================================================================

üîç Automatic Path Validation:
```rust
// Path validation for path/file options
if opt_name.contains("path") || opt_name.contains("file") {
    let path = Path::new(opt_value);
    if !path.exists() {
        eprintln!("Path does not exist: {}", opt_value);
        std::process::exit(1);
    }
}
```

‚ö†Ô∏è Built-in Safety:
- Any option containing "path" or "file" in name
- Automatically validated for existence
- Process exits with error if path doesn't exist

================================================================================
 üéØ MULTI-OPTION SYSTEM
================================================================================

üß™ Multi-Option Syntax:
```
--multi=a,b,!c
```

üîß Processing Logic:
- Comma separates different flags
- Exclamation mark (!) negates next flag
- Sets multiple opt_* variables:
  * opt_a="1"
  * opt_b="1"
  * opt_c="0" (negated)

================================================================================
 üîó GLOBAL CONTEXT ARCHITECTURE
================================================================================

üèóÔ∏è Context System Features:
- Variables stored in global namespace
- Thread-safe access (when properly initialized)
- Supports namespacing via ns_set/ns_get
- Environment variable import capabilities
- Config file application support

üéõÔ∏è Advanced Features:
```rust
// Namespaced variables
global::ns_set("app", "debug", "1");
global::ns_get("app", "debug");

// Environment import
hosts::global::import_env_with_prefix("MYAPP_", true);

// Config file application
global::apply_config_files(&["app.conf", "user.conf"]);
```

================================================================================
 üåü ROLO TRANSFORMATION GUIDELINES
================================================================================

‚úÖ CURRENT ROLO PATTERN (TO REPLACE):
```rust
struct CliConfig {
    verbose: bool,
    output_file: Option<String>,
    debug: bool,
}

fn parse_args(args: Vec<String>) -> CliConfig {
    // Custom parsing logic
    CliConfig { ... }
}

fn main() {
    let config = parse_args(env::args().collect());
    run_with_config(config);
}
```

‚úÖ NEW RSB PATTERN:
```rust
fn main() {
    let args = bootstrap!();  // Sets up global context
    options!(&args);          // Parses into opt_* variables

    dispatch!(&args, {
        "command1" => cmd1,
        "command2" => cmd2,
    });
}

fn cmd1(args: Args) -> i32 {
    // Access options via global context
    let verbose = global::is_true("opt_verbose");
    let output = global::get_var("opt_output_file");
    let debug = global::is_true("opt_debug");

    // Use values directly
    if verbose { println!("Verbose mode enabled"); }
    0
}
```

================================================================================
 üîÑ MIGRATION CHECKLIST
================================================================================

üéØ Step 1: Remove Custom Config
- Delete CliConfig struct definition
- Remove parse_args function
- Eliminate config parameter passing

üéØ Step 2: Add RSB Bootstrap
- Add bootstrap!() call at start of main()
- Add options!() call after bootstrap
- Replace manual arg parsing

üéØ Step 3: Update Command Functions
- Change signatures to fn(Args) -> i32
- Replace config.field access with global::get_var()
- Use global::is_true() for boolean options

üéØ Step 4: Update Option Access
- verbose: config.verbose ‚Üí global::is_true("opt_verbose")
- file: config.file ‚Üí global::get_var("opt_file")
- debug: config.debug ‚Üí global::is_true("opt_debug")

================================================================================
 üö® IMPORTANT GOTCHAS
================================================================================

‚ö†Ô∏è Variable Access:
- Always use "opt_" prefix for CLI options
- Dashes become underscores in variable names
- Empty string returned for unset variables

‚ö†Ô∏è Boolean Logic:
- Use is_true() not direct string comparison
- "1" = true, "0" = false, "" = false
- Negated options explicitly set to "0"

‚ö†Ô∏è Initialization Order:
1. bootstrap!() MUST come first
2. options!() MUST come before option access
3. dispatch!() comes last for routing

================================================================================
 üìà BENEFITS OF RSB GLOBAL CONTEXT
================================================================================

‚úÖ Eliminates Config Passing:
- No more threading config through function calls
- Global access from anywhere in codebase
- Cleaner function signatures

‚úÖ Standardized Patterns:
- Consistent opt_* naming convention
- Built-in boolean handling with is_true()
- Automatic path validation

‚úÖ Enhanced Features:
- Negation support (--not-flag)
- Multi-option parsing
- Standard option mappings
- Built-in help/inspect commands

================================================================================
 üîó REFERENCES
================================================================================

Source Files Analyzed:
- /home/xnull/repos/code/rust/oodx/rsb/src/cli/options.rs
- /home/xnull/repos/code/rust/oodx/rsb/src/hosts/global.rs
- /home/xnull/repos/code/rust/oodx/rsb/tests/options.rs

================================================================================
 üìã METADATA
================================================================================

Egg Type: Global Context Analysis
Target: RSB options and global variable system
Scope: CLI option parsing and global context access
Confidence: High (direct source analysis)
Focus: Replacing custom Config structs with global context

‚ö†Ô∏è DISCLAIMER: This summary reflects RSB global context patterns as of
analysis date. Verify current global module API before implementing.

================================================================================
 üêî CHINA'S SIGN-OFF
================================================================================

"From scattered config structs to unified global context - now that's what
I call gathering all the eggs in one basket! No more passing config around
like a hot potato! ü•î‚Üíü•ö"

               ~ China the Summary Chicken ~