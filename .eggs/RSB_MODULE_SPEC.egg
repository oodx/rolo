================================================================================
 ğŸ” CHINA'S RSB MODULE SPEC EGG #3 ğŸ¥š
================================================================================

Date: 2025-09-15
Time: Current session
Requestor: User
Purpose: RSB MODULE_SPEC compliance for proper rolo architecture

================================================================================
 ğŸ¯ EXECUTIVE SUMMARY
================================================================================

RSB MODULE_SPEC defines a strict organization pattern for Rust modules:
- mod.rs orchestrates and re-exports (NO business logic)
- utils.rs contains curated low-level helpers users opt into
- helpers.rs holds internal implementations
- macros.rs owns module-specific macros
- Cross-module integrations use adapter pattern to avoid circular deps

================================================================================
 ğŸ” CRITICAL DISCOVERY: MODULE LAYOUT ENFORCEMENT
================================================================================

RSB enforces SINGLE SOURCE OF TRUTH per module with specific file roles:

ğŸ“ MODULE STRUCTURE:
```
<module>/
â”œâ”€â”€ mod.rs       â† Orchestrator & re-exports (curated public surface)
â”œâ”€â”€ utils.rs     â† Curated low-level helpers ("utils" namespace)
â”œâ”€â”€ helpers.rs   â† Internal implementations (consumed by utils/orchestrator)
â”œâ”€â”€ macros.rs    â† Module-owned macros (value + var forms)
â””â”€â”€ error.rs     â† Typed error enums for consistent messaging
```

âš ï¸ CRITICAL RULE: mod.rs owns public surface, NO business logic allowed!

================================================================================
 ğŸ›ï¸ PRELUDE POLICY COMPLIANCE
================================================================================

ğŸ”§ Prelude Re-export Rules:
- Re-export user-facing items and module-owned macros via rsb::prelude::*
- DO NOT re-export internal submodules unless intentionally public/stable
- Optional/visual features MUST NOT leak into prelude
- Tests may import modules/macros directly as needed

ğŸ¯ Feature Flag Architecture:
```toml
[features]
default = []

# Visual base and components
visual = []
colors-simple = ["visual"]
colors-named  = ["visual", "colors-simple"]
colors-status = ["visual"]
glyphs = ["visual"]
prompts = ["visual", "colors-simple"]

# Umbrellas and convenience
colors  = ["visual", "colors-simple"]
visuals = ["visual", "colors-simple", "colors-named", "colors-status", "glyphs", "prompts"]

# Options helpers
stdopts = []
```

================================================================================
 ğŸ§© CROSS-MODULE INTEGRATION PATTERN
================================================================================

ğŸ”§ Adapter Pattern for Dependencies:
- Goal: Reuse helpers across modules WITHOUT circular dependencies
- Location: Consumer module only, in dedicated file
- Naming: `<module>_<dep>_adapter.rs` or `<module>_<dep>_shared.rs`

ğŸ§ª Adapter Template Example:
```rust
// math/math_string_adapter.rs
#[cfg(feature = "string")]
pub fn parse_num_list(s: &str) -> Vec<f64> {
    // Reuse string helpers to split/sanitize
    rsb::string::utils::filter_ascii_strip(s)
        .split(',')
        .filter_map(|t| t.trim().parse::<f64>().ok())
        .collect()
}

#[cfg(not(feature = "string"))]
pub fn parse_num_list(_s: &str) -> Vec<f64> {
    Vec::new() // safe fallback
}
```

ğŸ¯ Adapter Integration in mod.rs:
```rust
#[cfg(feature = "string")]
pub use self::math_string_adapter::parse_num_list;
```

================================================================================
 âš¡ MACRO DESIGN PRINCIPLES
================================================================================

ğŸ”§ Macro Guidelines:
- Keep macros THIN; delegate logic to helper functions
- Prefer value + var forms for string-oriented macros:
  * Value form: consumes provided value (e.g., snake!(s))
  * Var form: fetches from Context first (e.g., snake_var!("NAME"))
- Export module-owned macros at crate root
- Re-export via prelude::macros

ğŸ¯ param! Macro Pattern:
- param! stays crate-level as DSL router
- Delegates to helpers (e.g., string::utils, string::case)
- Push validation/logic into helper functions, not macros

================================================================================
 ğŸ”¤ ASCII-SAFE vs UNICODE-SAFE PATTERNS
================================================================================

ğŸ”§ Helper Classification:
- ASCII-SAFE: normalize output to ASCII (filenames/configs)
  * Non-ASCII treated as separator and stripped
- UNICODE-SAFE: operate on Unicode scalars via chars()
  * NOT graphemes - uses char boundaries

ğŸ·ï¸ Documentation Requirements:
- Tag helpers with ASCII-SAFE or UNICODE-SAFE labels
- Maintain registry for debug listing (optional)
- Clear semantics in function documentation

================================================================================
 ğŸ› ï¸ HELPER vs UTILS vs MACROS ORGANIZATION
================================================================================

ğŸ“Š Role Definitions:

ğŸ”§ helpers.rs:
- Internal implementations
- Consumed by utils and orchestrator
- Not directly user-facing
- Complex business logic lives here

ğŸ›ï¸ utils.rs:
- Curated low-level helpers
- Users explicitly opt into "utils" namespace
- Single source of truth for module functionality
- Depends on helpers.rs for implementation

ğŸ§ª macros.rs:
- Module-owned macros only
- Thin wrappers around helper functions
- Both value and var forms when applicable
- Exported at crate root

ğŸ“‹ mod.rs:
- Orchestrator ONLY
- Curated public surface
- Re-exports from utils/helpers/macros
- NO business logic whatsoever

================================================================================
 ğŸš« ERROR AND LOGGING CONVENTIONS
================================================================================

âš ï¸ Critical Rules:
- Core modules MUST NOT depend on optional visual macros
- Use utils::stderrx(level, msg) for best-effort, non-visual logging
- Wrap examples/tests using visual macros with #[cfg(feature = "visual")]

ğŸ”§ Error Handling:
- error.rs contains typed error enums
- Consistent messaging across module
- Integration with RSB error handling patterns

================================================================================
 ğŸŒŠ STREAMS INTEGRATION GUIDANCE
================================================================================

ğŸ”§ Heavy Transformations:
- Line-wise transformations belong in streams module
- Handles large inputs safely without memory issues
- Provide ergonomic wrappers in modules where it adds value

ğŸ¯ When to Use Streams:
- Case conversions on large files
- Line-by-line processing
- Memory-efficient transformations

================================================================================
 ğŸ§ª TESTING ARCHITECTURE
================================================================================

ğŸ”§ Testing Requirements:
- Include baseline sanity test for each module WITHOUT optional features
- Gate adapter/integration tests with required features
- Ensure runner lanes cover both default and feature-enabled profiles

ğŸ¯ Test Organization:
- tests/features/<module>/ for feature-gated tests
- At least one sanity test that doesn't require adapter features
- Use bin/test.sh lanes (smoke, all) and cargo feature combos

================================================================================
 ğŸŒŸ ROLO COMPLIANCE TRANSFORMATION
================================================================================

âœ… CURRENT ROLO ISSUES (TO FIX):
- Scattered helper functions
- No clear module organization
- Mixed business logic in main files
- No prelude strategy

âœ… RSB COMPLIANCE STEPS:

ğŸ¯ Step 1: Reorganize Module Structure
- Create proper mod.rs orchestrator
- Move helpers to helpers.rs
- Curate public API in utils.rs
- Extract macros to macros.rs

ğŸ¯ Step 2: Implement Adapter Pattern
- Identify cross-module dependencies
- Create <module>_<dep>_adapter.rs files
- Add feature gating for optional dependencies
- Provide graceful fallbacks

ğŸ¯ Step 3: Prelude Compliance
- Define what goes in public prelude
- Avoid leaking internal modules
- Feature-gate optional components
- Create curated re-export strategy

ğŸ¯ Step 4: Error Handling
- Create error.rs with typed enums
- Remove visual macro dependencies from core
- Use utils::stderrx for logging

================================================================================
 ğŸ“ FEATURE FLAG STRATEGY
================================================================================

ğŸ”§ Feature Organization:
- Base features (no dependencies)
- Visual features (colors, glyphs, prompts)
- Umbrella features (convenience groupings)
- Integration features (cross-module adapters)

ğŸ¯ Feature Isolation:
- Core modules work without optional features
- Graceful degradation when features disabled
- Clear feature boundaries and dependencies

================================================================================
 ğŸ”— COMPLIANCE CHECKLIST FOR ROLO
================================================================================

âœ… Module Structure:
- [ ] mod.rs orchestrates only, no business logic
- [ ] helpers.rs contains internal implementations
- [ ] utils.rs has curated public helpers
- [ ] macros.rs owns module-specific macros
- [ ] error.rs has typed error enums

âœ… Cross-Module Dependencies:
- [ ] Use adapter pattern for dependencies
- [ ] Feature-gate optional integrations
- [ ] Provide fallbacks for disabled features
- [ ] Avoid circular dependencies

âœ… Prelude Strategy:
- [ ] Curated re-exports only
- [ ] No internal module leaking
- [ ] Feature-gated optional components
- [ ] Clear public API surface

âœ… Testing:
- [ ] Baseline tests without features
- [ ] Feature-gated integration tests
- [ ] Both default and feature-enabled test lanes

================================================================================
 ğŸ”— REFERENCES
================================================================================

Source Files Analyzed:
- /home/xnull/repos/code/rust/oodx/rsb/docs/tech/development/MODULE_SPEC.md
- /home/xnull/repos/code/rust/oodx/rsb/docs/tech/development/PRELUDE_POLICY.md
- /home/xnull/repos/code/rust/oodx/rsb/Cargo.toml (feature flags)

Related Documents:
- FEATURES_GATING_PLAN.md
- HOWTO_TEST.md
- AST_CONSIDERATIONS.md

================================================================================
 ğŸ“‹ METADATA
================================================================================

Egg Type: Module Architecture Specification
Target: RSB MODULE_SPEC compliance requirements
Scope: Module organization, helpers, utils, macros, adapters
Confidence: High (official specification document)
Completeness: Full specification coverage

âš ï¸ DISCLAIMER: This summary reflects RSB MODULE_SPEC as of 2025-09-15.
Follow specification updates for latest compliance requirements.

================================================================================
 ğŸ” CHINA'S SIGN-OFF
================================================================================

"From chaotic code coops to organized module henhouses - now that's what I
call proper architectural nesting! Every helper in its place, every macro
in its roost! ğŸ ğŸ”"

               ~ China the Summary Chicken ~